import axios from "axios"
import { useCallback, useContext, useEffect, useMemo, useState } from "react"
import NFTNameGeneratorContext from "./NFTNameGeneratorContext"
import { storeBlob } from "../lib/ipfs"
import transformTwitterHandle from "../lib/transformTwitterHandle"

const textToImage = require("text-to-image")

export const useNFTNameGenerator = () => useContext(NFTNameGeneratorContext)

export const NFTNameGeneratorProvider = ({ children }) => {
  const [description, setDescription] = useState<string>("")
  const [twitterHandle, setTwitterHandle] = useState<string>("")
  const [publicWallet, setPublicWallet] = useState<string>("")
  const [loading, setLoading] = useState<boolean>(false)
  const [showResults, setShowResults] = useState<boolean>(false)
  const [name, setName] = useState<string>("")
  const [imageURI, setImageURI] = useState<string>("")
  const [twitterId, setTwitterId] = useState<string>("")
  const [tokenId, setTokenId] = useState<string>("")
  const [startConfetti, setStartConfetti] = useState<boolean>(false)
  const [txHash, setTxHash] = useState<string>("")
  const [haveTokenId, setHaveTokenId] = useState(false)

  function dataURLtoFile(dataurl, filename) {
    const arr = dataurl.split(",")
    const mime = arr[0].match(/:(.*?);/)[1]
    const bstr = atob(arr[1])
    let n = bstr.length
    const u8arr = new Uint8Array(n)

    // eslint-disable-next-line no-plusplus
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n)
    }
    return new File([u8arr], filename, { type: mime })
  }

  const checkTx = useCallback(async () => {
    const response = await axios.get("/api/getTxLogs", {
      params: {
        txHash,
      },
    })
    if (response) {
      setTokenId(parseInt(response.data.logs[0].topics[3], 16).toString())
      setHaveTokenId(true)
    }
  }, [txHash])

  const postTweet = useCallback(
    async (generatedName) => {
      const response = await axios.post("/api/tweet", {
        twitterHandle,
        generatedName,
      })
      return response
    },
    [twitterHandle],
  )

  const getGeneratedName = useCallback(async () => {
    const response = await axios.get("/api/randomName")
    return response.data
  }, [])

  const generateImageURI = useCallback(
    async (generatedName) =>
      textToImage.generate(generatedName, {
        debug: true,
        fontSize: 58,
        fontFamily: "Aileron",
        lineHeight: 58,
        margin: 5,
        customHeight: 500,
        maxWidth: 500,
        bgColor: "black",
        textColor: "white",
        textAlign: "center",
        verticalAlign: "center",
      }),
    [],
  )

  const mintGeneratedName = useCallback(
    async (ipfsUrl: string, generatedName: string, creator: string, recipient) => {
      const reciept = await axios.get("/api/mint", {
        params: {
          imageUri: ipfsUrl,
          name: generatedName,
          description: `${generatedName} generated by ${creator}`,
          recipient,
        },
      })
      return reciept
    },
    [],
  )
  const handleGenerateClick = useCallback(async () => {
    setLoading(true)
    const generated = await getGeneratedName()
    setName(generated)

    const dataUri = await generateImageURI(generated)
    setImageURI(dataUri)

    const file = dataURLtoFile(dataUri, "a.png")
    const ipfsUrl = await storeBlob(file)

    const generatedBy = transformTwitterHandle(twitterHandle)
    setDescription(`${generated} generated by ${generatedBy}`)
    const receipt = await mintGeneratedName(ipfsUrl, generated, generatedBy, publicWallet)
    if (receipt?.data?.txReceipt) {
      setTxHash(receipt.data.txReceipt)
    }
    if (receipt.status === 200) {
      setStartConfetti(true)
      setTimeout(() => {
        setStartConfetti(false)
        setShowResults(true)
      }, 5000)
    }
    const tweetResponse = await postTweet(generated)

    if (tweetResponse?.data?.data?.id) {
      setTwitterId(tweetResponse.data.data.id)
    }
    setLoading(false)
  }, [
    twitterHandle,
    postTweet,
    getGeneratedName,
    generateImageURI,
    mintGeneratedName,
    publicWallet,
  ])

  useEffect(() => {
    let timeout = null
    if (txHash.length > 0 && !haveTokenId) {
      timeout = setTimeout(() => {
        checkTx()
      }, 5000)
    }
    return () => timeout && clearTimeout(timeout)
  }, [txHash, haveTokenId, checkTx])

  const value = useMemo(
    () => ({
      twitterHandle,
      setTwitterHandle,
      publicWallet,
      setPublicWallet,
      loading,
      setLoading,
      showResults,
      setShowResults,
      name,
      setName,
      imageURI,
      setImageURI,
      twitterId,
      setTwitterId,
      tokenId,
      setTokenId,
      handleGenerateClick,
      description,
      startConfetti,
      haveTokenId,
    }),
    [
      twitterHandle,
      setTwitterHandle,
      publicWallet,
      setPublicWallet,
      loading,
      setLoading,
      showResults,
      setShowResults,
      name,
      setName,
      imageURI,
      setImageURI,
      twitterId,
      setTwitterId,
      tokenId,
      handleGenerateClick,
      description,
      startConfetti,
      haveTokenId,
    ],
  )
  return (
    <NFTNameGeneratorContext.Provider value={value}>{children}</NFTNameGeneratorContext.Provider>
  )
}
